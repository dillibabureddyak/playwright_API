"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-expect-error - no types
const matchers_1 = __importDefault(require("expect/build/matchers"));
const utils_1 = require("./utils");
const playwrightApiMatchers = {
    async toHaveStatusCode(response, expected) {
        const expectedMatcherName = 'toHaveStatusCode';
        const received = response.status();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toHaveStatusText(response, expected) {
        const expectedMatcherName = 'toHaveStatusText';
        const received = response.statusText();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toHaveJSON(response, expected) {
        const expectedMatcherName = 'toHaveJSON';
        const received = await response.json();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toEqual.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toContainJSON(response, expected) {
        const originalMatcherName = 'toContainEqual';
        const expectedMatcherName = 'toContainJSON';
        const received = await response.json();
        const { message: originalMessage, pass } = matchers_1.default.toContainEqual.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toMatchJSON(response, expected) {
        const originalMatcherName = 'toMatchObject';
        const expectedMatcherName = 'toMatchJSON';
        const received = await response.json();
        const { message: originalMessage, pass } = matchers_1.default.toMatchObject.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toContainTextContent(response, expected) {
        const expectedMatcherName = 'toContainTextContent';
        const received = await response.text();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toContain.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toHaveHeaders(response, expected) {
        const originalMatcherName = 'toMatchObject';
        const expectedMatcherName = 'toHaveHeaders';
        const received = response.headers();
        const { message: originalMessage, pass } = matchers_1.default.toMatchObject.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toHaveHeader(response, expectedKey, expectedValue) {
        const originalMatcherName = 'toHaveProperty';
        const expectedMatcherName = 'toHaveHeader';
        const received = response.headers();
        const expected = expectedValue ? [expectedKey, expectedValue] : [expectedKey];
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const { message: originalMessage, pass } = matchers_1.default.toHaveProperty.call({ ...this, customTesters: [] }, received, ...expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toHaveContentType(response, expected) {
        const expectedMatcherName = 'toHaveContentType';
        const received = response.headers();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received['content-type'], expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toHaveLocation(response, expected) {
        const expectedMatcherName = 'toHaveLocation';
        const received = response.headers();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received['location'], expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toBeCreated(response) {
        const expectedMatcherName = 'toBeCreated';
        const expected = 201;
        const received = response.status();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toBeUnauthorized(response) {
        const expectedMatcherName = 'toBeUnauthorized';
        const expected = 401;
        const received = response.status();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toBeForbidden(response) {
        const expectedMatcherName = 'toBeForbidden';
        const expected = 403;
        const received = response.status();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toBeNotFound(response) {
        const expectedMatcherName = 'toBeNotFound';
        const expected = 404;
        const received = response.status();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
    async toBeRedirected(response, expected) {
        const expectedMatcherName = 'toBeRedirected';
        const received = response.url();
        const { name: originalMatcherName, message: originalMessage, pass, } = matchers_1.default.toBe.call({ ...this, customTesters: [] }, received, expected);
        const message = () => (0, utils_1.normalize)(originalMessage(), originalMatcherName, expectedMatcherName);
        return { pass, message };
    },
};
exports.default = playwrightApiMatchers;
